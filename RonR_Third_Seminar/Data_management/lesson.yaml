- Class: meta
  Course: RonR! third
  Lesson: Data manipulation
  Author: Jorge Cimentada from Daniel Ciganda's material
  Type: Standard
  Organization: RECSM, UPF
  Version: 2.2.21
 
- Class: text
  Output: Hello and welcome to the second lesson of the 3rd seminar. In this lesson we're gonna cover
    some basic data manipulation like creating, renaming and recoding variables. In addition,
    we will cover how to subset and filter a data set.
        
- Class: text
  Output: We're gonna be using two of the datasets we opened in the previous lesson. Both
    datasets contain fertility rates for ages between 15 to 50. asfr7512 contains data from 1975
    to 2012 whereas asfr1314 contains data from years 2013 and 2014.
    
- Class: cmd_question
  Output: Let's start by reading the datasets. I created the path to where the data is in the
    data_dir vector. Using file.path(), data_dir and "asfr752012ine1.csv", read.csv() the file
    and assign it the name asfr7512.
  CorrectAnswer: asfr7512 <- read.csv(file.path(data_dir, "asfr752012ine1.csv"))
  AnswerTests: omnitest(correctExpr='asfr7512 <- read.csv(file.path(data_dir, "asfr752012ine1.csv"))')
  Hint: Your code should be something like new_name <- read.csv(complete_path.csv). Remember
    to use file.path() and the path and filename.csv to create the complete path.
    
- Class: cmd_question
  Output: Awesome. Now we have to read the asfr1314ine.txt file. This text file, however,
    has no-space delimited ("") rather than comma-delimited. Remember last lesson? Which function
    should we use instead of read.csv()? Following the same path and with this new name, do it
    yourself. Assign it the name asfr1314.
  CorrectAnswer: asfr1314 <- read.table(file.path(data_dir, "asfr1314ine.txt"), sep = "")
  AnswerTests: omnitest(correctExpr='asfr1314 <- read.table(file.path(data_dir, "asfr1314ine.txt"), sep = "")')
  Hint: The answer is the same as the previous one but swaping read.csv() for read.table(),
    the file names and specifying the 'sep' argument to be equal to "".
        
- Class: cmd_question
  Output: Take a look at the head of asfr7512.
  CorrectAnswer: head(asfr7512)
  AnswerTests: omnitest(correctExpr='head(asfr7512)')
  Hint: Use the head() function to take a look at the first few rows.
  
- Class: cmd_question
  Output: Do the same for asfr1314
  CorrectAnswer: head(asfr1314)
  AnswerTests: omnitest(correctExpr='head(asfr1314)')
  Hint: Use the head() function to take a look at the first few rows.
  
- Class: cmd_question
  Output: Check whether both datasets have the same number of rows. Do not use dim() but
    directly the nrow() function. Start with asfr7512.
  CorrectAnswer: nrow(asfr7512)
  AnswerTests: omnitest(correctExpr='nrow(asfr7512)')
  Hint: asfr7512 should be the only argument of nrow()
  
- Class: cmd_question
  Output: Repeat for asfr1314.
  CorrectAnswer: nrow(asfr1314)
  AnswerTests: omnitest(correctExpr='nrow(asfr1314)')
  Hint: asfr1314 should be the only argument of nrow()
  
- Class: text
  Output: We have two datasets which have THE SAME number of rows and we would like
    to merge them together (because they complement each other, one has two extra years).
  
- Class: text
  Output: 'We can use the cbind() function which stands for column bind. Its arguments are
    straightforward: cbind(object1, object2,..... objectN). As long as the objects have the
    same number of rows, cbind() will combine everything into one data frame.'

- Class: cmd_question
  Output: 'You should be able to combine both datasets without my help. Try it using these pointers:
        using cbind, include the datasets asfr7512 and asfr1314 as arguments.'
  CorrectAnswer: cbind(asfr7512, asfr1314)
  AnswerTests: omnitest(correctExpr='cbind(asfr7512, asfr1314)')
  Hint: We have two datasets which have to be used as the arguments of cbind.
    The correct expression would be cbind(asfr7512, asfr1314).
  
- Class: mult_question
  Output: Perfect! R binded both datasets without an error. But, there seems to be two
    problems we need to consider. Have a look at the last three columns. Which seems to
    be the problems?
  AnswerChoices: I don't see any problem; The three last columns are not in the correct order; Year 2013 is empty and Year 2014 is a character; Year 2013 is repeated twice and the order of cols is wrong; Column orders are wrong;
  CorrectAnswer: Year 2013 is repeated twice and the order of cols is wrong
  AnswerTests: omnitest(correctVal= 'Year 2013 is repeated twice and the order of cols is wrong')
  
- Class: text
  Output: Let's divide the problem into two parts. First, the last column of the asfr7512 is empty,
        we need to delete it. Second, the order of the columns in asfr1314 is incorrect and
        we need to reverse it. These two problems can be easily solved separately and THEN
        column bind the datasets.

- Class: text
  Output: Let's begin with the first problem.
  
- Class: cmd_question
  Output: Deleting columns in R is very easy. You can, for example, simply exclude the column.
    We can do that by subsetting all columns except the one you're interested in deleting. If
    there's 40 columns in asfr7512 and we want to exclude the last one, how would you do it?
    Don't save your results yet.
  CorrectAnswer: asfr7512[, 1:39]
  AnswerTests: omnitest(correctExpr='asfr7512[, 1:39]')
  Hint: We need to subset from column 1 to column 39 (excluding column 40). We do that with this
    skeleton data[, index of columns].
    
- Class: cmd_question
  Output: Another solution would be to only exclude the 40th column. We could do that very similarly
    to the previous answer but instead of choosing 1:39, we directly delete the 40th column.
    How do you think we could do that?
  CorrectAnswer: asfr7512[, -40]
  AnswerTests: omnitest(correctExpr='asfr7512[, -40]')
  Hint: The minus (-) sign is key here. Use the minus sign to remove only the 40th column.
    
- Class: cmd_question
  Output: That makes sense.. but in both examples we didn't really "delete" the column, we actually
    excluded it. There are many other ways how to properly deleted a column. One is to assign
    the column to NULL. Take asfr7512 and assign the 40th column to NULL. No need to save anything.
  CorrectAnswer: asfr7512[, 40] <- NULL
  AnswerTests: omnitest(correctExpr='asfr7512[, 40] <- NULL')
  Hint: Take the data[, 40], which subsets the 40th column and assign it a NULL.
  
- Class: cmd_question
  Output: To me, that's the most concise approach because we don't have to save anything. Don't
    believe me? Check the first few rows of asfr7512.
  CorrectAnswer: head(asfr7512)
  AnswerTests: omnitest(correctExpr='head(asfr7512)')
  Hint: Type head(asfr7512)
  
- Class: text
  Output: Without resaving the data frame, we set the column to NULL and now the data frame doesn't
    have the column.. cool, eh!? There are other ways of deleting columns but these approaches
    should have you ready for your own analysis.
    
- Class: text
  Output: One problem fixed! Now we have to go to asfr1314 and reverse the column order, right?

- Class: cmd_question
  Output: Visualize the first few rows of asfr1314.
  CorrectAnswer: head(asfr1314)
  AnswerTests: omnitest(correctExpr='head(asfr1314)')
  Hint: Type head(asfr1314)

- Class: cmd_question
  Output: Alright so column two needs to be in the first position and column one in the second
    position. Following this approach, the most logical thing to do is to subset c(2, 1) in
    the column index of the data frame, no? Try it.
  CorrectAnswer: asfr1314[, c(2, 1)]
  AnswerTests: omnitest(correctExpr='asfr1314[, c(2, 1)]')
  Hint: Include the vector c(2, 1) inside the column subsetting in the brackets.
  
- Class: cmd_question
  Output: Thats a very clean way of doing it. But usually we don't have such small datasets.
    Sometimes we have 250 columns or more. We usually want to subset by column names, instead
    of by indexes (+ imagine that the columns are not next to each other! so something like
    c(235, 43)). Following the same approach but using the column names in a character vector,
    subset the columns.
  CorrectAnswer: asfr1314[, c("X2013", "X2014")]
  AnswerTests: omnitest(correctExpr='asfr1314[, c("X2013", "X2014")]')
  Hint: Use the vector c("X2013", "X2014") as the subsetter.
  
- Class: text
  Output: Let's go back to the core rules. After the comma, inside the brackets, you subset columns.
    Before the comma you subset rows. After the comma you can use either the column index (such as
    c(1, 2, 7, 8) or 1:10 to get the first 10 columns) or you can subset columns by their names.
    Subsetting columns by their names is usually better because we don't have to worry about
    where the columns are, which is very tedious. However, if the names are very tricky, like the
    ones here, it's difficult to write.

- Class: cmd_question
  Output: Oh I forgot. We didn't save our dataset when we subsetted the previous columns!
    Copy the previous answer and assign it the same name asfr1314.
  CorrectAnswer: asfr1314 <- asfr1314[, c("X2013", "X2014")]
  AnswerTests: omnitest(correctExpr='asfr1314 <- asfr1314[, c("X2013", "X2014")]')
  Hint: Something like this data <- data[previous answer]

- Class: cmd_question
  Output: Great! Now cbind() those two badboys together and call the new dataset fertility_years.
  CorrectAnswer: fertility_years <- cbind(asfr7512, asfr1314)
  AnswerTests: omnitest(correctExpr='fertility_years <- cbind(asfr7512, asfr1314)')
  Hint: Something like this new_name <- cbind(data1, data2)

- Class: cmd_question
  Output: Check everything is correct by using head()
  CorrectAnswer: head(fertility_years)
  AnswerTests: omnitest(correctExpr='head(fertility_years)')
  Hint: head(fertility_years) gives you the first few rows.
  
- Class: text
  Output: Good job!
  
- Class: text
  Output: I don't know about you but to me the columns names are a bit ugly. What is it
    about the X000 format? We could do something much more easy to write, like the year alone.

- Class: cmd_question
  Output: Let's start small. We could change the variable name by creating a new variable
    with a different name, no? Follow these guidelines; assign fertility_years$X2014 to
    fertility_years$last_year
  CorrectAnswer: fertility_years$last_year <- fertility_years$X2014
  AnswerTests: omnitest(correctExpr='fertility_years$last_year <- fertility_years$X2014')
  Hint: data$new_var_name <- data$old_var_name
    
- Class: cmd_question
  Output: Check the output with head()
  CorrectAnswer: head(fertility_years)
  AnswerTests: omnitest(correctExpr='head(fertility_years)')
  Hint: head(fertility_years) should do it!
  
- Class: text
  Output: Check the last column. Same variable but with a different name! We could complement this
    by setting X2014 to NULL to delete the old column for good. This approach is useful sometimes,
    but not for when you want to change, let's say, all column names!
    
- Class: text
  Output: For that we have to use another strategy, like the names() function. I think an example
    will be much more informative.
    
- Class: cmd_question
  Output: Type names(fertility_years)
  CorrectAnswer: names(fertility_years)
  AnswerTests: omnitest(correctExpr='names(fertility_years)')
  Hint: Type names(fertility_years).

- Class: cmd_question
  Output: You get all column names. The interesting thing is that we can change specific names
    by assigning a string to specific names. Follow me on this one; write names(fertility_years)
    and next to it subset only the first string with the `[]` brackets. Next to this assign (<-)
    the name "age" in lowercase.
  CorrectAnswer: names(fertility_years)[1] <- "age"
  AnswerTests: omnitest(correctExpr='names(fertility_years)[1] <- "age"')
  Hint: This should be the approach names(data)[index_to_change] <- "new_name"
  
- Class: cmd_question
  Output: If you remembered correctly, "Age" was written with a capital "A". Check if that's
    the case now with head(fertility_years)
  CorrectAnswer: head(fertility_years)
  AnswerTests: omnitest(correctExpr='head(fertility_years)')
  Hint: Type head(fertility_years).
  
- Class: cmd_question
  Output: Good job! Let's take it every further. Let's change all column names. Let's start by
    creating the names vector. Create a vector with "AGE" as the first string, and then, inside
    the vector, also create a seq() from 1975 to 2014. Wrap the whole seq() expression with as.character()
    because we can't have 'numeric' names! Assign it the name new_name.
  CorrectAnswer: new_name <- c("AGE", as.character(seq(1975, 2014)))
  AnswerTests: omnitest(correctExpr='new_name <- c("AGE", as.character(seq(1975, 2014)))')
  Hint: The structure should be similar to this one; vector <- c("var_name", as.character(sequence))
  
- Class: cmd_question
  Output: Awesome! Now let's simply assign this vector to names(fertility_years)
  CorrectAnswer: names(fertility_years) <- new_name
  AnswerTests: omnitest(correctExpr='names(fertility_years) <- new_name')
  Hint: Take names(fertility_years) and <- the new_name vector.
  
- Class: cmd_question
  Output: Check all names are correct with head(fertility_years)
  CorrectAnswer: head(fertility_years)
  AnswerTests: omnitest(correctExpr='head(fertility_years)')
  Hint: Use head(fertility_years)
  
- Class: cmd_question
  Output: Surprise quiz! Using names() and fertility_years, can you change the
    LAST column name to "extra_variable"? Remember the `[]` to subset the last column.
    Use PLAIN numbers, not functions like ncol() (don't worry if you don't know what
    I'm talking about.)
  CorrectAnswer: names(fertility_years)[42] <- "extra_variable"
  AnswerTests: omnitest(correctExpr='names(fertility_years)[42] <- "extra_variable"')
  Hint: Okay, I'll give you a hint! It's the 42nd column. names(data)[42] <- "new_var"
    should do it.
    
- Class: cmd_question
  Output: Another surprise quiz! Can you now change the second and eleventh
    names to "cold_war" and "orwell"?
  CorrectAnswer: names(fertility_years)[c(2, 11)] <- c("cold_war", "orwell")
  AnswerTests: omnitest(correctExpr='names(fertility_years)[c(2, 11)] <- c("cold_war", "orwell")')
  Hint: C'mon! It's the same answer as before but instead using c(2, 11) and assigning two
    names inside a vector!
    
- Class: text
  Output: Very good job! You're getting good at this.
  
# Create a dummy for above/below some years.
# Do some recoding
# Do some row subsetting.

- Class: text
  Output: The only thing you shouldn't be familiar here is the rev() function. But don't worry about it,
    it simply takes anything, a vector, data frame and reverses the order of its contents.
    
- Class: cmd_question
  Output: Let's see the result! Type asfr
  CorrectAnswer: asfr
  AnswerTests: omnitest(correctExpr='asfr')
  Hint: Type asfr
  
- Class: text
  Output: The data is complete now. Before moving into recoding, let's do a final test on indexing columns.

- Class: mult_question
  Output: All of our columns are years except the first one, which is age. Suppose
        we want to divide all columns except the first one by 1000 and ASSIGN our changes to our
        dataset. What would be the correct expression?
  AnswerChoices: asfr[,2:ncol(asfr)] <- asfr[,2:ncol(asfr)]/1000;asfr[2:ncol(asfr)] <- asfr[2:ncol(asfr)]/1000;asfr[,2:ncol(asfr)]/1000
  CorrectAnswer: asfr[,2:ncol(asfr)] <- asfr[,2:ncol(asfr)]/1000
  AnswerTests: omnitest(correctVal='asfr[,2:ncol(asfr)] <- asfr[,2:ncol(asfr)]/1000')
  
- Class: text
  Output: You might not have noticed but the there were TWO correct answers. I'll let you discover
        which ones they were on your own ;)
        
- Class: text
  Output: Let's move on to recoding variables. Remember that our first variable in the dataset is
    Age from 15 to 50. Suppose we want to create a new variable that will give the value
    1 people between age 15 and 20, a value of 2 for people between 20 and 25, and so on.. until age 50.
    
- Class: text
  Output: Let's start by creating our new variable. To call any variable form a data frame we use the $ sing.
    Example = asfr$variablename. In order to create a variable we do the same but with a new name.
    We want to create a new variable named ageG that contains NA (missing values). 
    
- Class: cmd_question
  Output: We could do that by typing asfr$ageG <- NA. Do it yourself.
  CorrectAnswer: asfr$ageG <- NA
  AnswerTests: omnitest(correctExpr='asfr$ageG <- NA')
  Hint: Type asfr$ageG <- NA
  
- Class: mult_question
  Output: Our desired expression will read like this = take asfr$ageG(which is full of missing values) and where
        asfr$Age is bigger or equal to 15 and asfr$Age is less than 20, assign ageG to group 1.
        Following this exact sentence, what is the correct expression?
  AnswerChoices: asfr$ageG[asfr$Age >= 15 & asfr$Age < 20] <- 1;asfr$ageG[ ,asfr$Age >= 15 & asfr$Age < 20] <- 1;asfr$ageG  <- asfr$Age >= 15 & asfr$Age < 20 <- 1;asfr$ageG[asfr$Age >= 15 & < 20] <- 1
  CorrectAnswer: asfr$ageG[asfr$Age >= 15 & asfr$Age < 20] <- 1
  AnswerTests: omnitest(correctVal= 'asfr$ageG[asfr$Age >= 15 & asfr$Age < 20] <- 1')
  
- Class: cmd_question
  Output: Higher or equal to 15 and smaller than 20 is the first age group. The second age group
        would be higher or equal to 20 and smaller than 25. Type asfr$ageG[asfr$Age>=20 & asfr$Age<25] <- 2
        to get the correct result.
  CorrectAnswer: asfr$ageG[asfr$Age>=20 & asfr$Age<25] <- 2
  AnswerTests: omnitest(correctExpr='asfr$ageG[asfr$Age>=20 & asfr$Age<25] <- 2')
  Hint: Type asfr$ageG[asfr$Age>=20 & asfr$Age<25] <- 2
  
- Class: text
  Output: We won't do it for all age groups but the SAME sequence would go up to the 7th age group,
        which would be between 45 and 50 years.
        
- Class: text
  Output: There are much more efficient ways of doing this using loops and packages(such as
        car) but those are more advanced topics that you will learn in future lessons.

- Class: cmd_question
  Output: I don't know if you noticed but our variable names are incorrect. Type names(asfr) or colnames(asfr)
        to see the names of the columns.
  CorrectAnswer: any_of_exprs("names(asfr)", "colnames(asfr)")
  AnswerTests: any_of_exprs("names(asfr)", "colnames(asfr)")
  Hint: Type names(asfr) or colnames(asfr)
  
- Class: text
  Output: Let's change all column year names to exclude the X in front. Thinking it through,
        we could just take the vector of column names, exclude the first(Age) and last(ageG) column and
        replace the years with the correct year numbers.
        
- Class: cmd_question
  Output: Let's start by getting the vector without the first and last column. You can do so by typing
        colnames(asfr)[2:(ncol(asfr)-1)]. Try it.
  CorrectAnswer: colnames(asfr)[2:(ncol(asfr)-1)]
  AnswerTests: omnitest(correctExpr='colnames(asfr)[2:(ncol(asfr)-1)]')
  Hint: Type colnames(asfr)[2:(ncol(asfr)-1)]
  
- Class: text
  Output: Go over this line of code again. We take colnames(asfr) and we subset its contents from
        the second position UNTIL the last column, minus 1. ncol(asfr)-1 in this case would equal 41 because
        the dataframe has 42 columns minus 1.

- Class: cmd_question
  Output: That expression gives us the correct vector. Now we need to replace the column names with
        the correct ones. We need years from 1975 to 2014. Using the seq() function this is really simple.
        Try seq(1975,2014,1).
  CorrectAnswer: seq(1975,2014,1)
  AnswerTests: omnitest(correctExpr='seq(1975,2014,1)')
  Hint: Type seq(1975,2014,1)
  
- Class: cmd_question
  Output: Now put everything together, colnames(asfr)[2:(ncol(asfr)-1)] <- seq(1975, 2014,1). Type it!
  CorrectAnswer: colnames(asfr)[2:(ncol(asfr)-1)] <- seq(1975, 2014,1)
  AnswerTests: omnitest(correctExpr='colnames(asfr)[2:(ncol(asfr)-1)] <- seq(1975, 2014,1)')
  Hint: Put everything together by typing colnames(asfr)[2:(ncol(asfr)-1)] <- seq(1975, 2014,1)
  
- Class: text
  Output: We could've deleted the ageG column to exclude the -1 from the expression. We could have done it
        easily by assigning the desired column to NULL; asfr$ageG <- NULL would be the equivalent
        
- Class: mult_question
  Output: Surpise quiz! Suppose I have a vector named 'even' which has the sequence c(2,4,6,8..) up until the 
        number of columns of the dataset. If I wanted to work only with the even years of the dataset,
        which expression would do the trick? Remember that the first column is Age and the last column
        is ageG, so you have to delete them.
  AnswerChoices: asfr[, -c(1,ncol(asfr)][,even];asfr[, even];asfr[ -c(1,ncol(asfr)) , even];asfr[even]
  CorrectAnswer: asfr[, -c(1,ncol(asfr)][,even]
  AnswerTests: omnitest(correctVal= 'asfr[, -c(1,ncol(asfr)][,even]')

- Class: text
  Output: Before we finish let's introduce a command that can be handy = subset()
  
- Class: text
  Output: subset() takes a data frame as its first argument and subsets any condition for the rows and columns.
        I think two examples will suffice to make you understand.
        
- Class: text
  Output: We want to subset only people below 20 years. subset(asfr, Age<20) will do the trick.
  
- Class: cmd_question
  Output: If we add a comma to that expression then we can specify which columns we want. By default
        R chooses all columns. I want you to subset the asfr dataframe for observations below Age 20 and
        only for the second and third column. Don't assign it to any object. Hint = remember to concatenate
        both column numbers.
  CorrectAnswer: subset(asfr, Age<20, c(2,3))
  AnswerTests: omnitest(correctExpr='subset(asfr, Age<20, c(2,3))')
  Hint: Type subset(asfr, Age<20, c(2,3))
  
- Class: text
  Output: Great! Let's finish by creating a dummy variable. Dummy variables always contain either a 1
        or a 0. Suppose you have a gender variable which has 1 for males and 0 for females, then
        that's a dummy variable.
        
- Class: text
  Output: There are several ways of creating a dummy variable(for example with the which function). 
        I'm gonna try to show you a familiar way of doing it.
        
- Class: cmd_question
  Output: Let's suppose we want to create a new variable named low14 which has a 1 when the fertility
        rate in 2014 was SMALLER then 0.005 and 0 when it has higher. Let's create a variable
        with only zeros first. Type asfr$low14 <- 0
  CorrectAnswer: asfr$low14 <- 0
  AnswerTests: omnitest(correctExpr='asfr$low14 <- 0')
  Hint: Type asfr$low14 <- 0

- Class: text
  Output: Since R recycles numbers, it automatically repeates the 0 as many times as the data frame has rows.
    With that done, we only have to replace the 0 with a 1 where observations had a fertility
    rate lower than 0.005 in 2014.
    
- Class: cmd_question
  Output: 'We could do that the same way we recoded variables for the age groups: asfr$low14[asfr[,"2014"] < 0.05] <- 1. Type it!'
  CorrectAnswer: asfr$low14[asfr[,"2014"] < 0.05] <- 1
  AnswerTests: omnitest(correctExpr='asfr$low14[asfr[,"2014"] < 0.05] <- 1')
  Hint: Type asfr$low14[asfr[,"2014"] < 0.05] <- 1
  
- Class: text
  Output: Read it again and understand what we did before continuing.
        
- Class: cmd_question
  Output: Let's see if everything was correct type head(asfr,50) and confirm at least for some cases when asfr$low14 has a 1, column 2014 is below 0.05
  CorrectAnswer: head(asfr,50)
  AnswerTests: omnitest(correctExpr='head(asfr,50)')
  Hint: Type head(asfr,50)
  
- Class: text
  Output: You're all set. We covered a lot of material today, congrats!
